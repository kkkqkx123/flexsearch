# 查询协调器模块设计

## 一、模块概述

查询协调器是中间层的核心组件，负责接收来自 API 网关的查询请求，根据查询类型路由到不同的搜索引擎，并协调多个搜索引擎的并行执行和结果融合。使用 Go 语言实现，利用其并发特性和网络通信优势。

---

## 二、核心功能

### 2.1 功能列表

| 功能 | 描述 |
|------|------|
| **查询路由** | 根据查询类型和配置路由到合适的搜索引擎 |
| **并行执行** | 并行调用多个搜索引擎 |
| **结果融合** | 融合多个搜索引擎的结果 |
| **超时控制** | 控制每个查询的超时时间 |
| **错误处理** | 处理搜索引擎的错误和故障 |
| **缓存** | 缓存查询结果 |
| **查询优化** | 优化查询以提高性能 |
| **监控指标** | 收集查询性能指标 |

### 2.2 查询路由策略

| 查询类型 | 路由策略 | 理由 |
|---------|---------|------|
| **精确匹配** | FlexSearch | 性能最优 |
| **短语搜索** | FlexSearch | 支持短语匹配 |
| **模糊搜索** | FlexSearch | 支持模糊匹配 |
| **语义搜索** | Vector Search | 语义理解 |
| **混合搜索** | Hybrid (FlexSearch + Vector) | 兼顾精确和语义 |
| **复杂查询** | BM25 | 支持复杂评分 |
| **自动选择** | Coordinator 根据查询特征自动选择 | 智能路由 |

---

## 三、架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────┐
│         API 网关               │
└──────────────┬──────────────────────┘
               │ gRPC
               ▼
┌─────────────────────────────────────────┐
│         查询协调器               │
│  ┌──────────────┬──────────────┐       │
│  │ 查询路由器   │ 结果融合器   │       │
│  └──────────────┴──────────────┘       │
│  ┌──────────────┬──────────────┐       │
│  │ 查询优化器   │ 缓存管理器   │       │
│  └──────────────┴──────────────┘       │
└──────────────┬──────────────────────┘
               │
        ┌──────┼──────┬──────────┐
        │      │        │          │
        ▼      ▼        ▼          ▼
┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
│FlexSearch│ │  BM25    │ │  向量搜索  │ │  缓存    │
│ 服务     │ │  服务     │ │  服务      │ │  服务    │
└──────────┘ └──────────┘ └──────────┘ └──────────┘
```

### 3.2 目录结构

```
services/coordinator/
├── cmd/
│   └── main.go              # 入口文件
├── internal/
│   ├── config/              # 配置管理
│   │   ├── config.go       # 配置结构
│   │   └── engines.go      # 引擎配置
│   ├── router/              # 查询路由器
│   │   ├── router.go       # 路由决策
│   │   ├── strategy.go     # 路由策略
│   │   └── optimizer.go    # 查询优化器
│   ├── merger/              # 结果融合器
│   │   ├── merger.go       # 融合接口
│   │   ├── rrf.go          # RRF 策略
│   │   └── weighted.go     # 加权策略
│   ├── engine/              # 搜索引擎客户端
│   │   ├── client.go       # 客户端接口
│   │   ├── flexsearch.go   # FlexSearch 客户端
│   │   ├── bm25.go         # BM25 客户端
│   │   └── vector.go       # 向量搜索客户端
│   ├── cache/               # 缓存管理
│   │   ├── cache.go        # 缓存接口
│   │   └── redis.go        # Redis 缓存
│   ├── model/               # 数据模型
│   │   ├── request.go      # 请求模型
│   │   └── response.go     # 响应模型
│   └── util/                # 工具函数
│       ├── logger.go        # 日志工具
│       ├── metrics.go       # 监控指标
│       └── error.go         # 错误处理
├── proto/                   # gRPC 协议定义
│   └── coordinator.proto
├── configs/                 # 配置文件
│   └── config.yaml
├── go.mod
├── go.sum
├── Dockerfile
└── README.md
```

---

## 四、模块职责

### 4.1 查询路由器

**职责**：
- 分析查询特征
- 根据查询类型决定使用哪些搜索引擎
- 支持显式指定引擎和自动路由
- 实现查询优化

**主要逻辑**：
1. 分析查询特征（长度、类型、特殊字符等）
2. 检查是否显式指定了搜索引擎
3. 如果显式指定，直接使用指定引擎
4. 如果未指定，根据查询特征自动选择引擎
5. 返回需要调用的搜索引擎列表

**路由策略**：
- 短查询（< 3 个词）：使用 FlexSearch
- 包含通配符（*、?）：使用 FlexSearch
- 启用语义搜索：使用向量搜索
- 默认：混合搜索（FlexSearch + Vector）

### 4.2 结果融合器

**职责**：
- 融合多个搜索引擎的结果
- 支持多种融合策略
- 对融合后的结果进行排序
- 去重和截断

**主要逻辑**：
1. 接收多个搜索引擎的结果
2. 根据配置选择融合策略
3. 执行融合算法
4. 对融合后的结果进行排序
5. 去重和截断
6. 返回融合后的结果

**融合策略**：
- RRF（Reciprocal Rank Fusion）：基于排名的融合
- 加权融合：基于权重的融合
- 学习融合：基于机器学习的融合

### 4.3 搜索引擎客户端

**职责**：
- 管理与搜索引擎的 gRPC 连接
- 调用搜索引擎的接口
- 处理连接错误和超时
- 实现连接池和重试

**主要逻辑**：
1. 建立 gRPC 连接
2. 调用搜索引擎的搜索接口
3. 处理连接超时和错误
4. 实现连接池和重试机制
5. 监控搜索引擎的健康状态

**支持的引擎**：
- FlexSearch：关键词搜索
- BM25：全文搜索
- Vector：向量搜索

### 4.4 缓存管理器

**职责**：
- 缓存查询结果
- 管理缓存的过期和淘汰
- 提供缓存命中率统计
- 支持缓存预热

**主要逻辑**：
1. 生成缓存键
2. 检查缓存是否存在
3. 如果缓存命中，返回缓存结果
4. 如果缓存未命中，执行查询并缓存结果
5. 管理缓存的过期和淘汰
6. 统计缓存命中率

### 4.5 查询优化器

**职责**：
- 优化查询以提高性能
- 重写查询以提高准确性
- 提供查询建议
- 统计查询性能

**主要逻辑**：
1. 分析查询语句
2. 识别可以优化的部分
3. 重写查询语句
4. 提供查询建议
5. 统计查询性能

---

## 五、主要逻辑流程

### 5.1 查询处理流程

```
1. 接收来自 API 网关的查询请求
2. 检查缓存是否存在
3. 如果缓存命中，返回缓存结果
4. 如果缓存未命中，分析查询特征
5. 根据查询特征路由到合适的搜索引擎
6. 并行调用多个搜索引擎
7. 等待所有搜索引擎返回结果
8. 融合多个搜索引擎的结果
9. 缓存融合后的结果
10. 返回融合后的结果
```

### 5.2 查询路由流程

```
1. 分析查询特征
   - 查询长度
   - 查询类型（精确、模糊、短语等）
   - 特殊字符（通配符、布尔操作符等）
2. 检查是否显式指定了搜索引擎
3. 如果显式指定，直接使用指定引擎
4. 如果未指定，根据查询特征自动选择引擎
5. 返回需要调用的搜索引擎列表
```

### 5.3 并行执行流程

```
1. 创建多个 goroutine
2. 每个 goroutine 调用一个搜索引擎
3. 使用 WaitGroup 等待所有 goroutine 完成
4. 收集所有搜索引擎的结果
5. 处理超时和错误
6. 返回收集到的结果
```

### 5.4 结果融合流程

```
1. 接收多个搜索引擎的结果
2. 根据配置选择融合策略
3. 执行融合算法
   - RRF：基于排名的融合
   - 加权：基于权重的融合
4. 对融合后的结果进行排序
5. 去重和截断
6. 返回融合后的结果
```

### 5.5 缓存处理流程

```
1. 生成缓存键（基于查询参数）
2. 在 Redis 中查询缓存
3. 如果缓存命中
   - 返回缓存结果
   - 记录缓存命中
4. 如果缓存未命中
   - 执行查询
   - 缓存查询结果
   - 设置缓存过期时间
   - 记录缓存未命中
```

---

## 六、技术选型

### 6.1 核心依赖

| 依赖 | 用途 |
|------|------|
| gRPC | 服务间通信 |
| Redis | 缓存 |
| Zap | 日志系统 |
| Prometheus | 监控指标 |
| Viper | 配置管理 |

### 6.2 依赖说明

**gRPC**：
- 高效的 RPC 框架
- 支持 Protocol Buffers
- 支持流式传输

**Redis**：
- 高性能键值存储
- 支持查询缓存
- 支持分布式锁

**Zap**：
- 高性能日志库
- 结构化日志
- 支持多种输出

**Prometheus**：
- 监控指标收集
- 支持多种指标类型
- 支持指标导出

**Viper**：
- 强大的配置管理
- 支持多种配置格式
- 支持配置热更新

---

## 七、设计原则

### 7.1 架构原则

1. **并发优先**：使用 goroutine 实现并行查询
2. **容错性**：处理搜索引擎的错误和超时
3. **可扩展性**：易于添加新的搜索引擎
4. **性能优先**：缓存、并行执行、结果融合优化
5. **可观测性**：完善的日志、监控和追踪

### 7.2 代码原则

1. **简洁性**：代码简洁明了，易于理解和维护
2. **可测试性**：代码易于测试，单元测试覆盖率高
3. **模块化**：每个模块职责单一，高内聚低耦合
4. **错误处理**：完善的错误处理和恢复机制
5. **性能优化**：使用高效的算法和数据结构
