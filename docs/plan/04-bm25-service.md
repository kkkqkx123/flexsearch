# BM25 服务模块设计

## 一、模块概述

BM25 服务是中间层的全文搜索引擎，负责提供基于 BM25 算法的全文搜索功能。该服务使用 Rust 语言实现，利用其高性能计算和内存安全特性，实现高效的倒排索引和 BM25 评分算法。

---

## 二、核心功能

### 2.1 功能列表

| 功能 | 描述 |
|------|------|
| **文档索引** | 添加、更新、删除文档 |
| **全文搜索** | 基于 BM25 算法的全文搜索 |
| **字段加权** | 支持字段级别的权重配置 |
| **缓存管理** | 自动缓存热门查询 |
| **持久化** | 支持多种持久化后端 |
| **批量操作** | 支持批量添加和删除 |
| **高亮显示** | 搜索结果高亮 |
| **监控指标** | 收集性能指标 |

### 2.2 搜索特性

| 特性 | 支持 | 说明 |
|------|------|------|
| **BM25 评分** | ✅ | 基于 BM25 算法的相关性评分 |
| **字段加权** | ✅ | 支持字段级别的权重配置 |
| **短语搜索** | ✅ | 支持引号短语 |
| **布尔查询** | ✅ | AND、OR、NOT |
| **范围查询** | ✅ | 数值、日期范围 |
| **模糊匹配** | ✅ | 支持编辑距离模糊匹配 |
| **同义词扩展** | ✅ | 支持同义词扩展 |

---

## 三、架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────┐
│         查询协调器               │
└──────────────┬──────────────────────┘
               │ gRPC
               ▼
┌─────────────────────────────────────────┐
│         BM25 服务                 │
│  ┌──────────────┬──────────────┐       │
│  │ 索引管理器   │ 搜索管理器   │       │
│  └──────────────┴──────────────┘       │
│  ┌──────────────┬──────────────┐       │
│  │ 评分计算器   │ 缓存管理器   │       │
│  └──────────────┴──────────────┘       │
└──────────────┬──────────────────────┘
               │
        ┌──────┼──────┐
        │      │        │
        ▼      ▼        ▼
┌──────────┐ ┌──────────┐ ┌──────────┐
│倒排索引  │ │  Redis   │ │  文档存储 │
│ 内存索引  │ │  缓存    │ │  (可选)  │
└──────────┘ └──────────┘ └──────────┘
```

### 3.2 目录结构

```
services/bm25/
├── src/
│   ├── main.rs              # 入口文件
│   ├── lib.rs               # 库入口
│   ├── config/              # 配置管理
│   │   ├── mod.rs          # 模块入口
│   │   └── config.rs       # 配置结构
│   ├── index/               # 索引管理
│   │   ├── mod.rs          # 模块入口
│   │   ├── manager.rs      # 索引管理器
│   │   ├── builder.rs      # 索引构建器
│   │   └── inverted.rs     # 倒排索引
│   ├── search/              # 搜索管理
│   │   ├── mod.rs          # 模块入口
│   │   ├── manager.rs      # 搜索管理器
│   │   └── highlight.rs    # 高亮显示
│   ├── scorer/              # 评分计算
│   │   ├── mod.rs          # 模块入口
│   │   ├── bm25.rs         # BM25 评分
│   │   └── field.rs        # 字段加权
│   ├── tokenizer/           # 分词器
│   │   ├── mod.rs          # 模块入口
│   │   ├── simple.rs       # 简单分词器
│   │   └── advanced.rs     # 高级分词器
│   ├── cache/               # 缓存管理
│   │   ├── mod.rs          # 模块入口
│   │   └── redis.rs        # Redis 缓存
│   ├── storage/             # 持久化
│   │   ├── mod.rs          # 模块入口
│   │   └── redis.rs        # Redis 存储
│   ├── proto/               # gRPC 服务
│   │   ├── mod.rs          # 模块入口
│   │   └── service.rs       # gRPC 服务实现
│   └── model/               # 数据模型
│       ├── mod.rs          # 模块入口
│       ├── document.rs     # 文档模型
│       └── result.rs       # 结果模型
├── proto/                   # gRPC 协议定义
│   └── bm25.proto
├── configs/                 # 配置文件
│   └── config.toml
├── Cargo.toml               # Rust 项目配置
├── Dockerfile
└── README.md
```

---

## 四、模块职责

### 4.1 索引管理器

**职责**：
- 管理倒排索引的创建和更新
- 处理文档的添加、更新、删除
- 维护索引的内存结构
- 支持索引的持久化和恢复
- 维护词频和文档频率统计

**主要逻辑**：
1. 接收文档添加请求
2. 对文档内容进行分词
3. 将词项和文档 ID 的映射关系存入倒排索引
4. 更新词频和文档频率统计
5. 支持索引的增量更新和全量重建

**数据结构**：
- 倒排索引：词项到文档 ID 列表的映射
- 词频统计：词项在文档中的出现频率
- 文档频率统计：包含词项的文档数量
- 字段统计：字段级别的统计信息

### 4.2 搜索管理器

**职责**：
- 处理搜索请求
- 解析查询语句
- 在倒排索引中查找匹配的文档
- 对结果进行排序和截断

**主要逻辑**：
1. 接收搜索请求
2. 对查询进行分词
3. 在倒排索引中查找每个词项对应的文档
4. 对多个词项的结果进行交集或并集操作
5. 调用评分计算器计算相关性分数
6. 根据分数对结果进行排序
7. 返回排序后的结果

**查询处理**：
- 短语搜索：支持引号短语
- 布尔查询：支持 AND、OR、NOT 操作
- 模糊匹配：支持编辑距离模糊匹配
- 同义词扩展：支持同义词扩展

### 4.3 评分计算器

**职责**：
- 实现 BM25 评分算法
- 支持字段级别的权重配置
- 计算文档的相关性分数
- 支持自定义评分函数

**主要逻辑**：
1. 接收文档和查询词
2. 计算词频（TF）
3. 计算逆文档频率（IDF）
4. 应用 BM25 公式计算分数
5. 应用字段权重
6. 返回最终分数

**BM25 公式**：
```
score(D, Q) = Σ IDF(qi) * (f(qi, D) * (k1 + 1)) / (f(qi, D) + k1 * (1 - b + b * |D| / avgdl))
```

其中：
- `f(qi, D)`：词 qi 在文档 D 中的词频
- `|D|`：文档 D 的长度
- `avgdl`：平均文档长度
- `k1`：词频饱和参数
- `b`：长度归一化参数

**字段加权**：
- 为每个字段配置权重
- 在计算分数时应用字段权重
- 支持字段级别的 boost

### 4.4 分词器

**职责**：
- 对文本进行分词
- 支持多种分词模式
- 处理大小写和标点符号
- 支持停用词过滤
- 支持同义词扩展

**主要逻辑**：
1. 接收文本输入
2. 根据配置选择分词模式
3. 对文本进行分词
4. 处理大小写转换
5. 过滤停用词
6. 扩展同义词
7. 返回词项列表

**分词模式**：
- 简单分词：按空格和标点符号分词
- 高级分词：支持词干提取和词形还原
- 自定义分词：支持自定义分词规则

### 4.5 缓存管理器

**职责**：
- 缓存热门查询的结果
- 管理缓存的过期和淘汰
- 提供缓存命中率统计
- 支持缓存预热

**主要逻辑**：
1. 生成缓存键
2. 检查缓存是否存在
3. 如果缓存命中，返回缓存结果
4. 如果缓存未命中，执行查询并缓存结果
5. 管理缓存的过期和淘汰
6. 统计缓存命中率

**缓存策略**：
- LRU：最近最少使用淘汰
- TTL：基于时间的过期
- 容量限制：限制缓存大小

### 4.6 持久化管理器

**职责**：
- 将索引持久化到存储
- 从存储恢复索引
- 支持增量更新和全量同步
- 管理存储的连接和错误

**主要逻辑**：
1. 将倒排索引序列化
2. 将序列化的数据写入存储
3. 从存储读取序列化的数据
4. 反序列化并重建索引
5. 处理存储错误和重试

**存储后端**：
- Redis：高性能键值存储
- 文件系统：本地文件存储
- 数据库：支持多种数据库

### 4.7 高亮显示

**职责**：
- 在搜索结果中高亮显示匹配的关键词
- 支持多种高亮样式
- 提供上下文片段
- 处理多词高亮

**主要逻辑**：
1. 接收搜索结果和查询词
2. 在文档内容中查找匹配的位置
3. 在匹配位置周围添加高亮标记
4. 提取上下文片段
5. 返回高亮后的结果

---

## 五、主要逻辑流程

### 5.1 文档索引流程

```
1. 接收文档添加请求
2. 对文档内容进行分词
3. 对每个词项进行处理
   - 转换为小写
   - 过滤停用词
   - 扩展同义词
   - 提取词干
4. 将词项和文档 ID 的映射关系存入倒排索引
5. 更新词频和文档频率统计
6. 将文档内容存入文档存储
7. 持久化索引变更
8. 返回成功响应
```

### 5.2 搜索流程

```
1. 接收搜索请求
2. 检查缓存是否存在
3. 如果缓存命中，返回缓存结果
4. 如果缓存未命中
   - 对查询进行分词
   - 扩展同义词
   - 在倒排索引中查找每个词项对应的文档
   - 对多个词项的结果进行交集或并集操作
   - 对每个文档计算 BM25 分数
   - 应用字段权重
   - 根据分数对结果进行排序
   - 截断结果到指定数量
   - 缓存查询结果
5. 返回搜索结果
```

### 5.3 BM25 评分流程

```
1. 接收文档和查询词
2. 计算词频（TF）
   - 统计词项在文档中的出现次数
3. 计算逆文档频率（IDF）
   - IDF = log((N - df + 0.5) / (df + 0.5))
   - N：文档总数
   - df：包含词项的文档数量
4. 应用 BM25 公式计算分数
5. 应用字段权重
6. 返回最终分数
```

### 5.4 高亮显示流程

```
1. 接收搜索结果和查询词
2. 对查询词进行分词
3. 在文档内容中查找每个词项的匹配位置
4. 在匹配位置周围添加高亮标记
5. 提取上下文片段（可选）
6. 返回高亮后的结果
```

---

## 六、技术选型

### 6.1 核心依赖

| 依赖 | 用途 |
|------|------|
| Tokio | 异步运行时 |
| Tonic | gRPC 框架 |
| Redis | 缓存、存储 |
| Tracing | 日志系统 |
| Metrics | 监控指标 |
| Serde | 序列化/反序列化 |

### 6.2 依赖说明

**Tokio**：
- 异步运行时
- 高性能的异步 I/O
- 支持任务调度和定时器

**Tonic**：
- gRPC 框架
- 支持 Protocol Buffers
- 高性能的 RPC 通信

**Redis**：
- 高性能键值存储
- 支持缓存和持久化
- 支持分布式场景

**Tracing**：
- 结构化日志
- 支持分布式追踪
- 高性能的日志记录

**Metrics**：
- 监控指标收集
- 支持多种指标类型
- 支持指标导出

**Serde**：
- 序列化和反序列化
- 支持多种数据格式
- 高性能的数据转换

---

## 七、设计原则

### 7.1 架构原则

1. **性能优先**：使用高效的数据结构和算法
2. **内存安全**：利用 Rust 的所有权系统保证内存安全
3. **并发安全**：使用线程安全的数据结构
4. **可扩展性**：易于添加新的搜索特性
5. **可观测性**：完善的日志、监控和追踪

### 7.2 代码原则

1. **简洁性**：代码简洁明了，易于理解和维护
2. **可测试性**：代码易于测试，单元测试覆盖率高
3. **模块化**：每个模块职责单一，高内聚低耦合
4. **错误处理**：完善的错误处理和恢复机制
5. **文档完善**：提供详细的 API 文档和使用示例
